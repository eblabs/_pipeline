{
	"auto_complete":
	{
		"selected_items":
		[
			[
				"ROLE",
				"ROLE_TASK_TYPE"
			],
			[
				"inser",
				"insertChild"
			],
			[
				"item_",
				"item_hold"
			],
			[
				"action",
				"action_duplicate"
			],
			[
				"selec",
				"selectedItems"
			],
			[
				"clear",
				"clearFocus"
			],
			[
				"tas",
				"task_name"
			],
			[
				"_create",
				"_create_task"
			],
			[
				"attrI",
				"_attrItems"
			],
			[
				"task_",
				"task_create_window"
			],
			[
				"layout",
				"layout_name"
			],
			[
				"layout_",
				"layout_base"
			],
			[
				"_st",
				"_set_button_enabled"
			],
			[
				"list",
				"listView"
			],
			[
				"QS",
				"QSignalTaskCreation"
			],
			[
				"button",
				"button_create"
			],
			[
				"butto",
				"button_create"
			],
			[
				"wid",
				"widget_taskCreation"
			],
			[
				"Task",
				"TaskCreator"
			],
			[
				"lis",
				"listView"
			],
			[
				"task",
				"task"
			],
			[
				"ex",
				"extension"
			],
			[
				"fol",
				"folderPath_abs"
			],
			[
				"file",
				"filePaths"
			],
			[
				"fil",
				"filter_reg_exp_changed"
			],
			[
				"taskP",
				"taskPaths"
			],
			[
				"_",
				"__init__"
			],
			[
				"exc",
				"execptions"
			],
			[
				"get_",
				"get_files_from_path"
			],
			[
				"func",
				"function"
			],
			[
				"_item",
				"_item_data_changed"
			],
			[
				"te",
				"test"
			],
			[
				"items_",
				"items_collect"
			],
			[
				"kw",
				"kwargs"
			],
			[
				"kwargs",
				"kwargs_run"
			],
			[
				"QSig",
				"QSignalUpdatTaskKwargs"
			],
			[
				"taskK",
				"taskKwargsRun"
			],
			[
				"Pro",
				"PropertyItem"
			],
			[
				"index_",
				"index_value"
			],
			[
				"conver",
				"convert_data"
			],
			[
				"val",
				"val_parent"
			],
			[
				"conv",
				"convert_data"
			],
			[
				"is",
				"isinstance"
			],
			[
				"_add",
				"_add_selection"
			],
			[
				"action_add",
				"action_addSelect"
			],
			[
				"_set",
				"_set_selection"
			],
			[
				"_re",
				"_reset_value"
			],
			[
				"data",
				"data_property_keys"
			],
			[
				"iet",
				"itemKwargs"
			],
			[
				"key",
				"keyEdit"
			],
			[
				"col",
				"column_property"
			],
			[
				"kwargI",
				"kwargInfo_ui"
			],
			[
				"setE",
				"setEnabled"
			],
			[
				"regi",
				"register_attribute"
			],
			[
				"kwa",
				"kwargs_ui"
			],
			[
				"attr",
				"attrType"
			],
			[
				"P",
				"PROPERTY_ITEMS"
			],
			[
				"setM",
				"setMaximum"
			],
			[
				"_kw",
				"_kwargs_ui"
			],
			[
				"_task",
				"_taskKwargs"
			],
			[
				"range",
				"rangeValue"
			],
			[
				"kwar",
				"kwargInfo"
			],
			[
				"k",
				"kwargs"
			],
			[
				"ROLE_TASK_N",
				"ROLE_TASK_NAME"
			],
			[
				"QTre",
				"QTreeWidgetItem"
			],
			[
				"wdig",
				"widget_tree"
			],
			[
				"ROLE_",
				"ROLE_TASK_NAME"
			],
			[
				"att",
				"_attrItems"
			],
			[
				"QM",
				"QMessageBox"
			],
			[
				"lab",
				"label_"
			],
			[
				"QSi",
				"QSignalError"
			],
			[
				"menu",
				"menu_execute_all"
			],
			[
				"menu_",
				"menu_execute_sel"
			],
			[
				"men",
				"menu_execute_sel"
			],
			[
				"widget_",
				"widget_tree"
			],
			[
				"wi",
				"widget_tree"
			],
			[
				"QSignalR",
				"QSignalReload"
			],
			[
				"_wid",
				"_widget_shelf"
			],
			[
				"expa",
				"expand_collapse"
			],
			[
				"exp",
				"_expand"
			],
			[
				"expan",
				"expandAll"
			],
			[
				"run",
				"run_all_tasks"
			],
			[
				"menu_ex",
				"menu_execute_all"
			],
			[
				"run_",
				"run_sel_tasks"
			],
			[
				"execute_all_pre",
				"execute_all_pressed"
			],
			[
				"pre",
				"pre_build"
			],
			[
				"QSignal",
				"QSignalSection"
			],
			[
				"_it",
				"_itemRunner"
			],
			[
				"action_re",
				"action_reload"
			],
			[
				"_men",
				"_menu_widgets"
			],
			[
				"action_co",
				"action_color_reset"
			],
			[
				"act",
				"action_duplicate"
			],
			[
				"menu_e",
				"menu_execute_all"
			],
			[
				"me",
				"menu_execute_sel"
			],
			[
				"SC_REFRE",
				"SC_REFRESH_RUN"
			],
			[
				"ROLE_TASK",
				"ROLE_TASK_POST"
			],
			[
				"post",
				"post_build"
			],
			[
				"role",
				"ROLE_TASK_RUN"
			],
			[
				"SC_",
				"SC_STOP"
			],
			[
				"SC",
				"SC_EXECUTE_ALL"
			],
			[
				"stop",
				"stop_button_pressed"
			],
			[
				"pau",
				"pause_resume_pressed"
			],
			[
				"reload_e",
				"reload_execute_pressed"
			],
			[
				"exec",
				"execute_all_pressed"
			],
			[
				"cl",
				"clicked"
			],
			[
				"button_exe",
				"button_execute_all"
			],
			[
				"reload",
				"reload_pressed"
			],
			[
				"button_re",
				"button_reload"
			],
			[
				"_pa",
				"_pause"
			],
			[
				"_p",
				"_pause_resume_set"
			],
			[
				"button_",
				"button_pause_resume"
			],
			[
				"sub",
				"subMenu"
			],
			[
				"button_relo",
				"button_reload_execute"
			],
			[
				"relod",
				"reload_execute_val"
			],
			[
				"_menu",
				"_menu_execute_single"
			],
			[
				"upda",
				"update_name"
			],
			[
				"nameNew",
				"nameNew_add"
			],
			[
				"nameN",
				"nameNew"
			],
			[
				"item",
				"itemCount"
			],
			[
				"taskI",
				"taskInfo"
			],
			[
				"get",
				"getattr"
			],
			[
				"taskR",
				"taskReturn"
			],
			[
				"ROLE_TASKp",
				"ROLE_TASK_POST"
			],
			[
				"taskReturn_",
				"taskReturn_pre"
			],
			[
				"daa",
				"dataInfo"
			],
			[
				"sele",
				"selectedItems"
			],
			[
				"SC_R",
				"SC_RUN_ALL"
			],
			[
				"_action_ex",
				"_action_execute_all"
			]
		]
	},
	"buffers":
	[
		{
			"contents": "@@ -1,19 +1,17 @@\n# =================#\n# IMPORT PACKAGES  #\n# =================#\n# IMPORT PACKAGES\n\n# import PySide\ntry:\n\tfrom PySide2.QtCore import *\n\tfrom PySide2.QtGui import *\n\tfrom PySide2.QtWidgets import *\n\tfrom PySide2 import __version__\n\tfrom shiboken2 import wrapInstance\n    from PySide2.QtCore import *\n    from PySide2.QtGui import *\n    from PySide2.QtWidgets import *\n    from PySide2 import __version__\n    from shiboken2 import wrapInstance\nexcept ImportError:\n\tfrom PySide.QtCore import *\n\tfrom PySide.QtGui import *\n\tfrom PySide import __version__\n\tfrom shiboken import wrapInstance\n    from PySide.QtCore import *\n    from PySide.QtGui import *\n    from PySide import __version__\n    from shiboken import wrapInstance\n\n# import json\nimport json\n@ -27,587 +25,618 @@ from collections import OrderedDict\n# import maya\nimport maya.cmds as cmds\n\n# =================#\n#   GLOBAL VARS   #\n# =================#\nfrom . import Logger\n\nimport dev.rigging.task\nPROPERTY_ITEMS = dev.rigging.task.PROPERTY_ITEMS\n# CONSTANT\nimport dev.rigging.task.config.PROPERTY_ITEMS as PROPERTY_ITEMS\nPROPERTY_ITEMS = PROPERTY_ITEMS.PROPERTY_ITEMS\n\nROLE_ITEM_KWARGS = Qt.UserRole + 1\n\nROLE_TASK_KWARGS = Qt.UserRole + 4\nROLE_TASK_KWARGS_KEY = Qt.UserRole + 5\n# =================#\n#      CLASS       #\n# =================#\n\n\n#  CLASS\nclass PropertyEditor(QTreeView):\n\t\"\"\"base class for PropertyEditor\"\"\"\n\tdef __init__(self):\n\t\tsuper(PropertyEditor, self).__init__()\n\t\tself._property = []\n\t\tself._size = QSize(20,20)\n\t\tself._enable = True\n\n\t\tself.init_widget()\n\n\tdef init_widget(self):\n\t\t# different color each row\n\t\tself.setAlternatingRowColors(True) \n\t\t# show header so user can adjust the first column width\n\t\tself.setHeaderHidden(False)\n\t\t# last section stretch\n\t\tself.header().setStretchLastSection(True)\n\n\t\t# QStandardItemModel\n\t\tself._model = QStandardItemModel(0,2)\n\t\tself._model.setHeaderData(0, Qt.Horizontal, 'Properties')\n\t\tself._model.setHeaderData(1, Qt.Horizontal, '')\n\t\tself.setModel(self._model)\n\n\t\t# delegate\n\t\tdelegate = PropertyDelegate(self)\n\t\tdelegate.QSignalUpdateParent.connect(self._update_parent)\n\t\tdelegate.QSignalRebuildChild.connect(self._rebuild_child)\n\n\t\tself.setItemDelegate(delegate)\n\n\t\tself.right_click_menu()\n\n\t\tself.setContextMenuPolicy(Qt.CustomContextMenu)\n\t\tself.customContextMenuRequested.connect(self._show_menu)\n\n\tdef init_property(self, item):\n\t\t'''\n\t\tinitialize property\n\t\t'''\n\t\tself._task = item\n\t\tself.refresh()\n\n\t\tdata_property = item.data(0, ROLE_TASK_KWARGS)\n\t\tdata_property_keys = item.data(0, ROLE_TASK_KWARGS_KEY)\n\n\t\tfor key in data_property_keys:\n\t\t\tdata = data_property[key]\n\t\t\t# add row item\n\t\t\trow, template_child, keyEdit = self._add_row_item(key, itemKwargs=data, keyEdit=False)\n\n\t\t\t# add row\n\t\t\tself._model.appendRow(row)\n\n\t\t\t# loop downstream\n\t\t\t# get value\n\t\t\tif 'value' in data and data['value'] != None:\n\t\t\t\tval = data['value']\n\t\t\telse:\n\t\t\t\tval = data['default']\n\t\t\tself._add_child(row[0], val, template=template_child, keyEdit=keyEdit)\n\n\tdef refresh(self):\n\t\tself.setEnabled(True)\n\t\tself._model.clear()\n\t\tself._model = QStandardItemModel(0,2)\n\t\tself._model.setHeaderData(0, Qt.Horizontal, 'Properties')\n\t\tself._model.setHeaderData(1, Qt.Horizontal, '')\n\t\tself.setModel(self._model)\n\t\t\n\tdef enable_widget(self):\n\t\tself._enable = not self._enable\n\t\tself.setEnabled(self._enable)\n\n\tdef right_click_menu(self):\n\t\tself.menu = QMenu()\n\t\tself.action_reset = self.menu.addAction('Reset Value')\n\t\tself.menu.addSeparator()\n\t\tself.action_setSelect = self.menu.addAction('Set Selection')\n\t\tself.action_addSelect = self.menu.addAction('Add Selection')\n\t\tself.menu.addSeparator()\n\t\tself.action_addElement = self.menu.addAction('Add Element')\n\t\tself.action_delElement = self.menu.addAction('Remove Element')\n\t\tself.action_dupElement = self.menu.addAction('Duplicate Element')\n\n\t\tfor action in [self.action_setSelect,\n\t\t\t\t\t   self.action_addSelect,\n\t\t\t\t\t   self.action_addElement,\n\t\t\t\t\t   self.action_delElement,\n\t\t\t\t\t   self.action_dupElement]:\n\t\t\taction.setEnabled(False)\n\n\t\t# connect function\n\t\tself.action_reset.triggered.connect(self._reset_value)\n\t\tself.action_setSelect.triggered.connect(self._set_selection)\n\t\tself.action_addSelect.triggered.connect(self._add_selection)\n\t\tself.action_addElement.triggered.connect(self._add_element)\n\t\tself.action_delElement.triggered.connect(self._del_element)\n\t\tself.action_dupElement.triggered.connect(self._dup_element)\n\n\tdef _add_child(self, item, data, template=None, keyEdit=False):\n\t\tif isinstance(data, list):\n\t\t\t# loop in each item in list\t\n\t\t\tfor i, val in enumerate(data):\n\t\t\t\trow, template_child, keyEdit = self._add_row_item(str(i), val=val, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t itemKwargs={'type':template})\n\n\t\t\t\t# add row\n\t\t\t\titem.appendRow(row)\n\n\t\t\t\t# loop downstream\n\t\t\t\tself._add_child(row[0], val, template=template_child)\n\n\t\telif isinstance(data, dict):\n\t\t\tfor key, val in data.iteritems():\n\t\t\t\t\n\t\t\t\tif template:\n\t\t\t\t\tif isinstance(template, dict):\n\t\t\t\t\t\tif key in template:\n\t\t\t\t\t\t\tattrType = template[key]\n\t\t\t\t\t\telse:\n\t\t\t\t\t\t\tattrType = None\n\t\t\t\t\telse:\n\t\t\t\t\t\tattrType = template\n\t\t\t\telse:\n\t\t\t\t\tattrType = None\n\n\t\t\t\trow, template_child, keyEdit = self._add_row_item(key, val=val, \n\t\t\t\t\t\t\t\t\t\t\t\t\t\t itemKwargs={'type':attrType},\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t keyEdit=keyEdit)\n\n\t\t\t\t# add row\n\t\t\t\titem.appendRow(row)\n\n\t\t\t\t# loop downstream\n\t\t\t\tself._add_child(row[0], val, template=template_child, keyEdit=keyEdit)\n\n\tdef _update_parent(self, item):\n\t\t# get item parent\n\t\tparent = item.parent()\n\t\tif parent:\n\t\t\t# get index\n\t\t\tindex_parent = parent.index()\n\t\t\t# get value index\n\t\t\tindex_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\t\t\t# get value\n\t\t\tvalue = convert_data(self._model.data(index_value))\n\t\t\t# get childs row count\n\t\t\trow_childs = parent.rowCount()\n\t\t\t# create empty container for update val\n\t\t\tif isinstance(value, list):\n\t\t\t\tvalue_collect = []\n\t\t\telse:\n\t\t\t\tvalue_collect = {}\n\t\t\t# loop in each row\n\t\t\tfor i in range(row_childs):\n\t\t\t\tindex_attr = self._model.index(i, 0, parent=index_parent)\n\t\t\t\tindex_val = self._model.index(i, 1, parent=index_parent)\n\t\t\t\tattr = convert_data_to_str(self._model.data(index_attr))\n\t\t\t\tval = convert_data(self._model.data(index_val))\n\t\t\t\tif isinstance(value, list):\n\t\t\t\t\tvalue_collect.append(convert_data_to_str(val))\n\t\t\t\telse:\n\t\t\t\t\tvalue_collect.update({attr: convert_data_to_str(val)})\n\t\t\t# assign data\n\t\t\tif value != value_collect:\n\t\t\t\tself._model.setData(index_value, convert_data_to_str(value_collect))\n\n\t\t\t# loop to upper level\n\t\t\tself._update_parent(self._model.itemFromIndex(index_parent))\n\t\telse:\n\t\t\tindex_key = self._model.index(item.row(), 0, parent=item.index().parent())\n\t\t\tindex_value = self._model.index(item.row(), 1, parent=item.index().parent())\n\t\t\titem_data = self._model.itemFromIndex(index_value)\n\t\t\tkey = self._model.data(index_key)\n\t\t\tval = convert_data(item_data.text())\n\t\t\titemKwargs = item_data.data(role=ROLE_ITEM_KWARGS)\n\t\t\titemKwargs.update({'value': val})\n\t\t\t\n\t\t\ttaskKwargs = self._task.data(0, ROLE_TASK_KWARGS) # get task kwargs\n\t\t\ttaskKwargs[key]['value'] = val\n\t\t\tself._task.setData(0, ROLE_TASK_KWARGS, taskKwargs) # set back to task\n\t\t\t\n\tdef _rebuild_child(self, item):\n\t\tindex_value = item.index()\n\t\tindex_attr = self._model.index(item.row(), 0, parent=index_value.parent())\n\t\t# get value\n\t\tvalue = convert_data(self._model.data(index_value))\n\t\tif isinstance(value, list) or isinstance(value, dict):\n\t\t\titem_attr = self._model.itemFromIndex(index_attr)\n\t\t\t# clear out the childs\n\t\t\trows = item_attr.rowCount()\n\t\t\titem_attr.removeRows(0, rows)\n\t\t\t# get template\n\t\t\titemKwargs = item.data(role=ROLE_ITEM_KWARGS)\n\t\t\tif itemKwargs and 'template' in itemKwargs:\n\t\t\t\ttemplate = itemKwargs['template']\n\t\t\telse:\n\t\t\t\ttemplate = None\n\t\t\t# get keyEdit\n\t\t\tkeyEdit = False\n\t\t\tif itemKwargs and 'keyEdit' in itemKwargs:\n\t\t\t\tkeyEdit = itemKwargs['keyEdit']\n\n\t\t\t# rebuild\n\t\t\tself._add_child(item_attr, value, template=template, keyEdit=keyEdit)\n\n\tdef _add_row_item(self, key, val=None, itemKwargs={}, keyEdit=False):\n\t\t# column 1: property name\n\t\tcolumn_property = QStandardItem(key)\n\t\t# key edit\n\t\tif keyEdit:\n\t\t\tcolumn_property.setEditable(True)\n\t\telse:\n\t\t\tcolumn_property.setEditable(False)\n\t\tcolumn_property.setData(self._size, role=Qt.SizeHintRole)\n\n\t\t# update kwargs\n\t\tif 'type' in itemKwargs and itemKwargs['type']:\n\t\t\tkwargs_add = PROPERTY_ITEMS[itemKwargs['type']]\n\t\t\tkwargs_add.update(itemKwargs)\n\t\t\titemKwargs = kwargs_add\n\n\t\t# column 2: value\n\t\tif val != None:\n\t\t\titemKwargs.update({'value': val})\n\n\t\tcolumn_val = PropertyItem(dataInfo=itemKwargs)\n\n\t\tif 'height' in itemKwargs:\n\t\t\tsize = QSize(self._size.width(), itemKwargs['height'])\n\t\t\n\t\t\tcolumn_property.setData(size, role=Qt.SizeHintRole)\n\n\t\t# get template\n\t\tif 'template' in itemKwargs:\n\t\t\ttemplate = itemKwargs['template']\n\t\telse:\n\t\t\ttemplate = None\n\n\t\t# get keyEdit\n\t\tkeyEdit = False\n\t\tif 'keyEdit' in itemKwargs:\n\t\t\tkeyEdit = itemKwargs['keyEdit']\n\n\t\treturn [column_property, column_val], template, keyEdit\n\n\tdef _show_menu(self, QPos):\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\t\tcolumn = item.column()\n\t\tif column > 0:\n\t\t\tpos = self.viewport().mapToGlobal(QPos)        \n\t\t\tself.menu.move(pos)\n\n\t\t\tdataInfo = item.data(role=ROLE_ITEM_KWARGS)\n\n\t\t\tif 'select' in dataInfo and dataInfo['select']:\n\t\t\t\tself.action_setSelect.setEnabled(True)\n\t\t\t\tif 'template' in dataInfo and dataInfo['template'] != None:\n\t\t\t\t\tself.action_addSelect.setEnabled(True)\n\t\t\t\telse:\n\t\t\t\t\tself.action_addSelect.setEnabled(False)\n\t\t\telse:\n\t\t\t\tself.action_setSelect.setEnabled(False)\n\t\t\t\tself.action_addSelect.setEnabled(False)\n\t\t\t\n\t\t\tif 'template' in dataInfo and dataInfo['template'] != None:\n\t\t\t\tself.action_addElement.setEnabled(True)\n\t\t\telse:\n\t\t\t\tself.action_addElement.setEnabled(False)\n\n\t\t\tparent = item.parent()\n\t\t\tif parent:\n\t\t\t\t# get index\n\t\t\t\tindex_parent = parent.index()\n\t\t\t\t# get value index\n\t\t\t\tindex_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\t\t\t\t# parent value item\n\t\t\t\titem_attr = self._model.itemFromIndex(index_value)\n\t\t\t\tdataInfo = item_attr.data(role=ROLE_ITEM_KWARGS)\n\t\t\t\tif 'template' in dataInfo and dataInfo['template'] != None:\n\t\t\t\t\tself.action_delElement.setEnabled(True)\n\t\t\t\t\tself.action_dupElement.setEnabled(True)\n\t\t\t\telse:\n\t\t\t\t\tself.action_delElement.setEnabled(False)\n\t\t\t\t\tself.action_dupElement.setEnabled(False)\n\t\t\telse:\n\t\t\t\tself.action_delElement.setEnabled(False)\n\t\t\t\tself.action_dupElement.setEnabled(False)\n\t\t\tself.menu.show()\n\n\tdef _reset_value(self):\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\t\tdataInfo = item.data(role=ROLE_ITEM_KWARGS)\t\n\t\tvalue = dataInfo['default']\n\t\titem.setText(convert_data_to_str(value))\n\t\tself._rebuild_child(item)\n\t\tself._update_parent(item)\n\n\tdef _set_selection(self):\n\t\t'''\n\t\tset select node as attr\n\t\t'''\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\n\t\tsel = cmds.ls(selection=True)\n\n\t\tif sel:\n\t\t\tdataInfo = item.data(role=ROLE_ITEM_KWARGS)\n\t\t\tif 'template' in dataInfo and dataInfo['template'] != None:\n\t\t\t\t# item is list\n\t\t\t\titem.setText(convert_data_to_str(sel))\n\t\t\t\tself._rebuild_child(item)\n\t\t\telse:\n\t\t\t\titem.setText(convert_data_to_str(sel[0]))\n\t\t\tself._update_parent(item)\t\t\t\t\n\n\tdef _add_selection(self):\n\t\t'''\n\t\tadd select node to attr\n\t\t'''\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\n\t\tval = item.text()\n\t\t# convert value\n\t\tval = convert_data(val)\n\t\t# get selection\n\t\tsel = cmds.ls(selection=True)\n\t\t# add selection\n\t\tif sel:\n\t\t\tval += sel\n\t\t\tval = list(OrderedDict.fromkeys(val))\n\t\t\titem.setText(convert_data_to_str(val))\n\t\t\tself._rebuild_child(item)\n\t\t\tself._update_parent(item)\n\n\tdef _add_element(self):\n\t\t'''\n\t\tadd element to list or dict\n\t\t'''\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\n\t\tval = item.text()\n\t\t# convert value\n\t\tval = convert_data(val)\n\n\t\tif isinstance(val, list):\n\t\t\t'''\n\t\t\tlist attr\n\t\t\t'''\n\t\t\tval.append('')\n\t\telse:\n\t\t\t'''\n\t\t\tdict attr\n\t\t\t'''\n\t\t\tval.update({val.keys()[-1]+'_copy': ''})\n\t\titem.setText(convert_data_to_str(val))\n\t\tself._rebuild_child(item)\n\t\tself._update_parent(item)\n\n\tdef _dup_element(self):\n\t\t'''\n\t\tduplicate current item\n\t\t'''\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\n\t\tval = convert_data(item.text())\n\n\t\t# get parent val\n\t\tparent = item.parent()\n\t\tindex_parent = parent.index()\n\t\t# get value index\n\t\tindex_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\t\t# get parent value item\n\t\titem_parent = self._model.itemFromIndex(index_value)\n\t\t# get value\n\t\tval_parent = convert_data(self._model.data(index_value))\n\n\t\tif isinstance(val_parent, list):\n\t\t\tval_parent.append(val)\n\t\telse:\n\t\t\t# get key\n\t\t\tindex_parent = self._model.index(item.row(), 0, parent=index_parent)\n\t\t\tkey = convert_data(self._model.data(index_parent))\n\t\t\tval_parent.update({key+'_copy': val})\n\t\titem_parent.setText(convert_data_to_str(val_parent))\n\t\tself._rebuild_child(item_parent)\n\t\tself._update_parent(item_parent)\n\t\tself.setCurrentIndex(index)\n\n\tdef _del_element(self):\n\t\t'''\n\t\tdelete current item\n\t\t'''\n\t\tindex = self.currentIndex()\n\t\titem = self._model.itemFromIndex(index)\n\n\t\tval = convert_data(item.text())\n\n\t\t# get parent val\n\t\tparent = item.parent()\n\t\tindex_parent = parent.index()\n\t\t# get value index\n\t\tindex_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\t\t# get parent value item\n\t\titem_parent = self._model.itemFromIndex(index_value)\n\t\t# get value\n\t\tval_parent = convert_data(self._model.data(index_value))\n\n\t\tif isinstance(val_parent, list):\n\t\t\tval_parent.remove(val)\n\t\telse:\n\t\t\t# get key\n\t\t\tindex_parent = self._model.index(item.row(), 0, parent=index_parent)\n\t\t\tkey = convert_data(self._model.data(index_parent))\n\t\t\tval_parent.pop(key)\n\t\titem_parent.setText(convert_data_to_str(val_parent))\n\t\tself._rebuild_child(item_parent)\n\t\tself._update_parent(item_parent)\n\t\tself.setCurrentIndex(QModelIndex())\n    \"\"\"base class for PropertyEditor\"\"\"\n    def __init__(self):\n        super(PropertyEditor, self).__init__()\n        self._property = []\n        self._size = QSize(20, 20)\n        self._enable = True\n        self._item = None  # store property item for further use\n\n        # different color each row\n        self.setAlternatingRowColors(True)\n        # show header so user can adjust the first column width\n        self.setHeaderHidden(False)\n        # last section stretch\n        self.header().setStretchLastSection(True)\n\n        # QStandardItemModel\n        self._model = QStandardItemModel(0, 2)\n        self._model.setHeaderData(0, Qt.Horizontal, 'Properties')\n        self._model.setHeaderData(1, Qt.Horizontal, '')\n        self.setModel(self._model)\n\n        # delegate\n        delegate = PropertyDelegate(self)\n        delegate.SIGNAL_UPDATE_PARENT.connect(self._update_parent)\n        delegate.SIGNAL_REBUILD_CHILD.connect(self._rebuild_child)\n\n        self.setItemDelegate(delegate)\n\n        # right click menu\n        self.menu = QMenu()\n        self.action_reset = self.menu.addAction('Reset Value')\n        self.menu.addSeparator()\n        self.action_set_select = self.menu.addAction('Set Selection')\n        self.action_add_select = self.menu.addAction('Add Selection')\n        self.menu.addSeparator()\n        self.action_add_element = self.menu.addAction('Add Element')\n        self.action_del_element = self.menu.addAction('Remove Element')\n        self.action_dup_element = self.menu.addAction('Duplicate Element')\n\n        for action in [self.action_set_select,\n                       self.action_add_select,\n                       self.action_add_element,\n                       self.action_del_element,\n                       self.action_dup_element]:\n            action.setEnabled(False)\n\n        # connect function\n        self.action_reset.triggered.connect(self._reset_value)\n        self.action_set_select.triggered.connect(self._set_selection)\n        self.action_add_select.triggered.connect(self._add_selection)\n        self.action_add_element.triggered.connect(self._add_element)\n        self.action_del_element.triggered.connect(self._del_element)\n        self.action_dup_element.triggered.connect(self._dup_element)\n\n        self.setContextMenuPolicy(Qt.CustomContextMenu)\n        self.customContextMenuRequested.connect(self._show_menu)\n\n    def init_property(self, item):\n        \"\"\"\n        initialize property\n\n        Args:\n            item(QTreeWidgetItem): given task item\n        \"\"\"\n\n        self._item = item  # store the given task item\n        self.refresh()\n\n        data_property = item.data(0, ROLE_TASK_KWARGS)\n        data_property_keys = item.data(0, ROLE_TASK_KWARGS_KEY)\n\n        for key in data_property_keys:\n            data = data_property[key]\n            # add row item\n            row, template_child, key_edit = self._add_row_item(key, item_kwargs=data, key_edit=False)\n\n            # add row\n            self._model.appendRow(row)\n\n            # loop downstream\n            # get value\n            if 'value' in data and data['value'] is not None:\n                val = data['value']\n            else:\n                val = data['default']\n            self._add_child(row[0], val, template=template_child, key_edit=key_edit)\n\n    def refresh(self):\n        self.setEnabled(True)\n        self._model.clear()\n        self._model = QStandardItemModel(0, 2)\n        self._model.setHeaderData(0, Qt.Horizontal, 'Properties')\n        self._model.setHeaderData(1, Qt.Horizontal, '')\n        self.setModel(self._model)\n\n    def enable_widget(self):\n        self._enable = not self._enable\n        self.setEnabled(self._enable)\n\n    def _add_child(self, item, data, template=None, key_edit=False):\n        \"\"\"\n        add child items to the given item\n\n        Args:\n            item(QStandardItem):\n            data: item's value\n\n        Keyword Args:\n            template(dict): item's template info, used for add item for list/dict item\n            key_edit(bool): if key is editable, only used for dict item\n        \"\"\"\n        if isinstance(data, list):\n            # loop in each item in list\n            for i, val in enumerate(data):\n                row, template_child, key_edit = self._add_row_item(str(i), val=val, item_kwargs={'type': template})\n\n                # add row\n                item.appendRow(row)\n\n                # loop downstream\n                self._add_child(row[0], val, template=template_child)\n\n        elif isinstance(data, dict):\n            for key, val in data.iteritems():\n                if template:\n                    if isinstance(template, dict):\n                        if key in template:\n                            attr_type = template[key]\n                        else:\n                            attr_type = None\n                    else:\n                        attr_type = template\n                else:\n                    attr_type = None\n\n                row, template_child, key_edit = self._add_row_item(key, val=val, item_kwargs={'type': attr_type},\n                                                                   key_edit=key_edit)\n\n                # add row\n                item.appendRow(row)\n\n                # loop downstream\n                self._add_child(row[0], val, template=template_child, key_edit=key_edit)\n\n    def _update_parent(self, item):\n        # get item parent\n        parent = item.parent()\n        if parent:\n            # get index\n            index_parent = parent.index()\n\n            # get value index\n            index_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\n            # get value\n            value = convert_data(self._model.data(index_value))\n\n            # get children row count\n            row_children = parent.rowCount()\n\n            # create empty container for update val\n            if isinstance(value, list):\n                value_collect = []\n            else:\n                value_collect = {}\n\n            # loop in each row\n            for i in range(row_children):\n                index_attr = self._model.index(i, 0, parent=index_parent)\n                index_val = self._model.index(i, 1, parent=index_parent)\n                attr = convert_data_to_str(self._model.data(index_attr))\n                val = convert_data(self._model.data(index_val))\n                if isinstance(value, list):\n                    value_collect.append(convert_data_to_str(val))\n                else:\n                    value_collect.update({attr: convert_data_to_str(val)})\n\n            # assign data\n            if value != value_collect:\n                self._model.setData(index_value, convert_data_to_str(value_collect))\n\n            # loop to upper level\n            self._update_parent(self._model.itemFromIndex(index_parent))\n        else:\n            index_key = self._model.index(item.row(), 0, parent=item.index().parent())\n            index_value = self._model.index(item.row(), 1, parent=item.index().parent())\n            item_data = self._model.itemFromIndex(index_value)\n            key = self._model.data(index_key)\n            val = convert_data(item_data.text())\n            item_kwargs = item_data.data(role=ROLE_ITEM_KWARGS)\n            item_kwargs.update({'value': val})\n\n            task_kwargs = self._task.data(0, ROLE_TASK_KWARGS)  # get task kwargs\n            task_kwargs[key]['value'] = val\n            self._item.setData(0, ROLE_TASK_KWARGS, task_kwargs)  # set back to task item\n\n    def _rebuild_child(self, item):\n        index_value = item.index()\n        index_attr = self._model.index(item.row(), 0, parent=index_value.parent())\n\n        # get value\n        value = convert_data(self._model.data(index_value))\n        if isinstance(value, list) or isinstance(value, dict):\n            item_attr = self._model.itemFromIndex(index_attr)\n\n            # clear out the children\n            rows = item_attr.rowCount()\n            item_attr.removeRows(0, rows)\n\n            # get template\n            item_kwargs = item.data(role=ROLE_ITEM_KWARGS)\n            if item_kwargs and 'template' in item_kwargs:\n                template = item_kwargs['template']\n            else:\n                template = None\n\n            # get key_edit value\n            key_edit = False\n            if item_kwargs and 'keyEdit' in item_kwargs:\n                key_edit = item_kwargs['keyEdit']\n\n            # rebuild\n            self._add_child(item_attr, value, template=template, key_edit=key_edit)\n\n    def _add_row_item(self, key, val=None, item_kwargs=None, key_edit=False):\n        if item_kwargs is None:\n            item_kwargs = {}\n\n        # column 1: property name\n        column_property = QStandardItem(key)\n\n        # key edit value\n        if key_edit:\n            column_property.setEditable(True)\n        else:\n            column_property.setEditable(False)\n\n        column_property.setData(self._size, role=Qt.SizeHintRole)\n\n        # update kwargs\n        if 'type' in item_kwargs and item_kwargs['type']:\n            kwargs_add = PROPERTY_ITEMS[item_kwargs['type']].copy()  # make a copy so the config won't be changed\n            kwargs_add.update(item_kwargs)\n            item_kwargs = kwargs_add\n\n        # column 2: value\n        if val is not None:\n            item_kwargs.update({'value': val})\n\n        column_val = PropertyItem(data_info=item_kwargs)\n\n        if 'height' in item_kwargs:\n            size = QSize(self._size.width(), item_kwargs['height'])\n\n            column_property.setData(size, role=Qt.SizeHintRole)\n\n        # get template\n        if 'template' in item_kwargs:\n            template = item_kwargs['template']\n        else:\n            template = None\n\n        # get key_edit val\n        key_edit = False\n        if 'key_edit' in item_kwargs:\n            key_edit = item_kwargs['key_edit']\n\n        return [column_property, column_val], template, key_edit\n\n    def _show_menu(self, pos):\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n        column = item.column()\n        if column > 0:\n            pos = self.viewport().mapToGlobal(pos)\n            self.menu.move(pos)\n\n            data_info = item.data(role=ROLE_ITEM_KWARGS)\n\n            if 'select' in data_info and data_info['select']:\n                self.action_set_select.setEnabled(True)\n                if 'template' in data_info and data_info['template'] is not None:\n                    self.action_add_select.setEnabled(True)\n                else:\n                    self.action_add_select.setEnabled(False)\n            else:\n                self.action_set_select.setEnabled(False)\n                self.action_add_select.setEnabled(False)\n\n            if 'template' in data_info and data_info['template'] is not None:\n                self.action_add_element.setEnabled(True)\n            else:\n                self.action_add_element.setEnabled(False)\n\n            parent = item.parent()\n            if parent:\n                # get index\n                index_parent = parent.index()\n\n                # get value index\n                index_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\n                # parent value item\n                item_attr = self._model.itemFromIndex(index_value)\n\n                data_info = item_attr.data(role=ROLE_ITEM_KWARGS)\n                if 'template' in data_info and data_info['template'] is not None:\n                    self.action_del_element.setEnabled(True)\n                    self.action_dup_element.setEnabled(True)\n                else:\n                    self.action_del_element.setEnabled(False)\n                    self.action_dup_element.setEnabled(False)\n            else:\n                self.action_del_element.setEnabled(False)\n                self.action_dup_element.setEnabled(False)\n\n            self.menu.show()\n\n    def _reset_value(self):\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n        data_info = item.data(role=ROLE_ITEM_KWARGS)\n        value = data_info['default']\n        item.setText(convert_data_to_str(value))\n        self._rebuild_child(item)\n        self._update_parent(item)\n\n    def _set_selection(self):\n        \"\"\"\n        set selected nodes as attr\n        \"\"\"\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n\n        sel = cmds.ls(selection=True)\n\n        if sel:\n            data_info = item.data(role=ROLE_ITEM_KWARGS)\n            if 'template' in data_info and data_info['template'] is not None:\n                # item is list\n                item.setText(convert_data_to_str(sel))\n                self._rebuild_child(item)\n            else:\n                item.setText(convert_data_to_str(sel[0]))\n\n            self._update_parent(item)\n\n    def _add_selection(self):\n        \"\"\"\n        add selected nodes to attr\n        \"\"\"\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n\n        val = item.text()\n        # convert value\n        val = convert_data(val)\n        # get selection\n        sel = cmds.ls(selection=True)\n        # add selection\n        if sel:\n            val += sel\n            val = list(OrderedDict.fromkeys(val))\n            item.setText(convert_data_to_str(val))\n            self._rebuild_child(item)\n            self._update_parent(item)\n\n    def _add_element(self):\n        \"\"\"\n        add element to list or dict\n        \"\"\"\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n\n        val = item.text()\n        # convert value\n        val = convert_data(val)\n\n        if isinstance(val, list):\n            # list attr\n            val.append('')\n        else:\n            # dict attr\n            val.update({val.keys()[-1]+'_copy': ''})\n\n        item.setText(convert_data_to_str(val))\n\n        self._rebuild_child(item)\n        self._update_parent(item)\n\n    def _dup_element(self):\n        \"\"\"\n        duplicate current item\n        \"\"\"\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n\n        val = convert_data(item.text())\n\n        # get parent val\n        parent = item.parent()\n        index_parent = parent.index()\n\n        # get value index\n        index_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\n        # get parent value item\n        item_parent = self._model.itemFromIndex(index_value)\n\n        # get value\n        val_parent = convert_data(self._model.data(index_value))\n\n        if isinstance(val_parent, list):\n            val_parent.append(val)\n        else:\n            # get key\n            index_parent = self._model.index(item.row(), 0, parent=index_parent)\n            key = convert_data(self._model.data(index_parent))\n            val_parent.update({key+'_copy': val})\n\n        item_parent.setText(convert_data_to_str(val_parent))\n\n        self._rebuild_child(item_parent)\n        self._update_parent(item_parent)\n        self.setCurrentIndex(index)\n\n    def _del_element(self):\n        \"\"\"\n        delete current item\n        \"\"\"\n        index = self.currentIndex()\n        item = self._model.itemFromIndex(index)\n\n        val = convert_data(item.text())\n\n        # get parent val\n        parent = item.parent()\n        index_parent = parent.index()\n\n        # get value index\n        index_value = self._model.index(parent.row(), 1, parent=index_parent.parent())\n\n        # get parent value item\n        item_parent = self._model.itemFromIndex(index_value)\n\n        # get value\n        val_parent = convert_data(self._model.data(index_value))\n\n        if isinstance(val_parent, list):\n            val_parent.remove(val)\n        else:\n            # get key\n            index_parent = self._model.index(item.row(), 0, parent=index_parent)\n            key = convert_data(self._model.data(index_parent))\n            val_parent.pop(key)\n        item_parent.setText(convert_data_to_str(val_parent))\n        self._rebuild_child(item_parent)\n        self._update_parent(item_parent)\n        self.setCurrentIndex(QModelIndex())\n\n\nclass PropertyDelegate(QItemDelegate):\n\t\"\"\"\n\tbase class for PropertyDelegate\n\tPropertyDelegate will create the correct widget base on property type\n\t\"\"\"\n\tQSignalUpdateParent = Signal(QStandardItem)\n\tQSignalRebuildChild = Signal(QStandardItem)\n\n\tdef __init__(self, parent=None):\n\t\tsuper(PropertyDelegate, self).__init__(parent)\n\t\t\n\tdef createEditor(self, parent, option, index):\n\t\titem = index.model().itemFromIndex(index)\n\n\t\tdataInfo = item.data(role=ROLE_ITEM_KWARGS)\n\n\t\tvalue = index.data()\n\n\t\tif dataInfo:\n\t\t\twidget = dataInfo['widget'](parent)\n\t\telse:\n\t\t\twidget = QLineEdit(parent)\n\n\t\t# extra setting\n\t\tif isinstance(widget, QComboBox):\n\t\t\t# set enum\n\t\t\twidget.addItems(dataInfo['enum'])\n\t\t\tenumIndex = widget.findText(value, Qt.MatchFixedString)\n\t\t\twidget.setCurrentIndex(enumIndex)\n\n\t\telif isinstance(widget, QDoubleSpinBox) or isinstance(widget, QSpinBox):\n\t\t\t# set range\n\t\t\tif 'min' in dataInfo and dataInfo['min'] != None:\n\t\t\t\twidget.setMinimum(dataInfo['min'])\n\t\t\tif 'max' in dataInfo and dataInfo['max'] != None:\n\t\t\t\twidget.setMaximum(dataInfo['max'])\n\n\t\telif isinstance(widget, QLineEdit):\n\t\t\twidget.setFrame(False)\n\n\t\treturn widget\n\n\tdef setEditorData(self, editor, index):\n\t\tsuper(PropertyDelegate, self).setEditorData(editor, index)\n\n\tdef setModelData(self, editor, model, index):\n\t\titem = index.model().itemFromIndex(index)\n\t\t# get previous value\n\t\tvalue = item.text()\n\n\t\t# get data info\n\t\tdataInfo = item.data(role=ROLE_ITEM_KWARGS)\t\n\n\t\t# set data\n\t\tsuper(PropertyDelegate, self).setModelData(editor, model, index)\n\t\t\n\t\tif not dataInfo:\n\t\t\t# shoot rebuild signal\n\t\t\tself.QSignalUpdateParent.emit(item)\n\t\t\treturn\n\n\t\t# if it's string/list/dict\n\t\tif isinstance(editor, QLineEdit):\n\t\t\t# get default value\n\t\t\tvalue_default = dataInfo['default']\n\t\t\t# get changed value\n\t\t\tvalue_change = item.text()\n\t\t\t# convert value\n\t\t\tvalue_change = convert_data(value_change)\n\n\t\t\t# if string and changed value is not \n\t\t\tif isinstance(value_default, basestring) and not isinstance(value_change, basestring):\n\t\t\t\t# change back to previous\n\t\t\t\titem.setText(value)\n\t\t\t# if list\n\t\t\telif isinstance(value_default, list):\n\t\t\t\tif isinstance(value_change, list):\n\t\t\t\t\t# shoot signal\n\t\t\t\t\tself.QSignalRebuildChild.emit(item)\n\n\t\t\t\telse:\n\t\t\t\t\t# change back to previous\n\t\t\t\t\titem.setText(value)\n\n\t\t\t# if dict\n\t\t\telif isinstance(value_default, dict):\n\t\t\t\tif isinstance(value_change, dict):\n\t\t\t\t\t# shoot signal\n\t\t\t\t\tself.QSignalRebuildChild.emit(item)\n\t\t\t\telse:\n\t\t\t\t\t# change back to previous\n\t\t\t\t\titem.setText(value)\n\n\t\t# shoot rebuild signal\n\t\tself.QSignalUpdateParent.emit(item)\n    \"\"\"\n    base class for PropertyDelegate\n    PropertyDelegate will create the correct widget base on property type\n    \"\"\"\n    SIGNAL_UPDATE_PARENT = Signal(QStandardItem)\n    SIGNAL_REBUILD_CHILD = Signal(QStandardItem)\n\n    def __init__(self, parent=None):\n        super(PropertyDelegate, self).__init__(parent)\n\n    def createEditor(self, parent, option, index):\n        item = index.model().itemFromIndex(index)\n\n        data_info = item.data(role=ROLE_ITEM_KWARGS)\n\n        value = index.data()\n\n        if data_info:\n            widget = data_info['widget'](parent)\n        else:\n            widget = QLineEdit(parent)\n\n        # extra setting\n        if isinstance(widget, QComboBox):\n            # set enum\n            widget.addItems(data_info['enum'])\n            enum_index = widget.findText(value, Qt.MatchFixedString)\n            widget.setCurrentIndex(enum_index)\n\n        elif isinstance(widget, QDoubleSpinBox) or isinstance(widget, QSpinBox):\n            # set range\n            if 'min' in data_info and data_info['min'] is not None:\n                widget.setMinimum(data_info['min'])\n            if 'max' in data_info and data_info['max'] is not None:\n                widget.setMaximum(data_info['max'])\n\n        elif isinstance(widget, QLineEdit):\n            widget.setFrame(False)\n\n        return widget\n\n    def setModelData(self, editor, model, index):\n        item = index.model().itemFromIndex(index)\n        # get previous value\n        value = item.text()\n\n        # get data info\n        data_info = item.data(role=ROLE_ITEM_KWARGS)\n\n        # set data\n        super(PropertyDelegate, self).setModelData(editor, model, index)\n\n        if not data_info:\n            # shoot rebuild signal\n            self.SIGNAL_UPDATE_PARENT.emit(item)\n            return\n\n        # if it's string/list/dict\n        if isinstance(editor, QLineEdit):\n            # get default value\n            value_default = data_info['default']\n            # get changed value\n            value_change = item.text()\n            # convert value\n            value_change = convert_data(value_change)\n\n            # if string and changed value is not\n            if isinstance(value_default, basestring) and not isinstance(value_change, basestring):\n                # change back to previous\n                item.setText(value)\n            # if list\n            elif isinstance(value_default, list):\n                if isinstance(value_change, list):\n                    # shoot signal\n                    self.SIGNAL_REBUILD_CHILD.emit(item)\n                else:\n                    # change back to previous\n                    item.setText(value)\n\n            # if dict\n            elif isinstance(value_default, dict):\n                if isinstance(value_change, dict):\n                    # shoot signal\n                    self.SIGNAL_REBUILD_CHILD.emit(item)\n                else:\n                    # change back to previous\n                    item.setText(value)\n\n        # shoot rebuild signal\n        self.SIGNAL_UPDATE_PARENT.emit(item)\n\n\nclass PropertyItem(QStandardItem):\n\t\"\"\"\n\tbase class for PropertyItem\n\tPropertyItem register all the data info into QStandardItem\n\tso it can be query or recreate later\n\tespically for list and dictionary, \n\tit hold the template to add items \n\t\"\"\"\n\tdef __init__(self, dataInfo={}):\n\t\tsuper(PropertyItem, self).__init__()\n    \"\"\"\n    base class for PropertyItem\n    PropertyItem register all the data info into QStandardItem\n    so it can be query or recreate later\n    especially for list and dictionary,\n    it hold the template to add items\n    \"\"\"\n    def __init__(self, data_info=None):\n        super(PropertyItem, self).__init__()\n\n\t\tself._data_info = dataInfo\n        if data_info is None:\n            data_info = {}\n\n\t\tself._set_data()\n        self._data_info = data_info\n\n\tdef _set_data(self):\n\t\tif 'value' in self._data_info and self._data_info['value'] != None:\n\t\t\tval = self._data_info['value']\n\t\telse:\n\t\t\tval = self._data_info['default']\n\t\tval = convert_data_to_str(val)\n        self._set_data()\n\n\t\tself.setText(val)\n    def _set_data(self):\n        if 'value' in self._data_info and self._data_info['value'] is not None:\n            val = self._data_info['value']\n        else:\n            val = self._data_info['default']\n\n\t\tself.setData(self._data_info, role=ROLE_ITEM_KWARGS)\n        val = convert_data_to_str(val)\n\n\t\tif 'hint' in self._data_info and self._data_info['hint']:\n\t\t\tself.setData(self._data_info['hint'], Qt.ToolTipRole)\n        self.setText(val)\n\n# =================#\n#      FUNCTION    #\n# =================#\n        self.setData(self._data_info, role=ROLE_ITEM_KWARGS)\n\n        if 'hint' in self._data_info and self._data_info['hint']:\n            self.setData(self._data_info['hint'], Qt.ToolTipRole)\n\n\n# FUNCTION\ndef convert_data(value):\n\ttry:\n\t\tvalue = ast.literal_eval(value)\n\texcept:\n\t\tpass\n\treturn value\n    try:\n        value = ast.literal_eval(value)\n    except ValueError:\n        # given value is str\n        pass\n    return value\n\n\ndef convert_data_to_str(value):\n\tif isinstance(value, list) or isinstance(value, dict):\n\t\tvalue = json.dumps(value)\n\telse:\n\t\tvalue = str(value)\n\treturn value\n    if isinstance(value, list) or isinstance(value, dict):\n        value = json.dumps(value)\n    else:\n        value = str(value)\n    return value",
			"settings":
			{
				"buffer_size": 37796,
				"line_ending": "Windows",
				"name": "@@ -1,19 +1,17 @@"
			}
		}
	],
	"build_system": "Packages/Python/Python.sublime-build",
	"build_system_choices":
	[
		[
			[
				[
					"Packages/Python/Python.sublime-build",
					""
				],
				[
					"Packages/Python/Python.sublime-build",
					"Syntax Check"
				]
			],
			[
				"Packages/Python/Python.sublime-build",
				""
			]
		]
	],
	"build_varint": "",
	"command_palette":
	{
		"height": 392.0,
		"last_filter": "",
		"selected_items":
		[
			[
				"pack",
				"Package Control: Install Package"
			]
		],
		"width": 468.0
	},
	"console":
	{
		"height": 283.0,
		"history":
		[
			"import urllib.request,os,hashlib; h = '6f4c264a24d933ce70df5dedcf1dcaee' + 'ebe013ee18cced0ef93d5f746d80ef60'; pf = 'Package Control.sublime-package'; ipp = sublime.installed_packages_path(); urllib.request.install_opener( urllib.request.build_opener( urllib.request.ProxyHandler()) ); by = urllib.request.urlopen( 'http://packagecontrol.io/' + pf.replace(' ', '%20')).read(); dh = hashlib.sha256(by).hexdigest(); print('Error validating download (got %s instead of %s), please try manual install' % (dh, h)) if dh != h else open(os.path.join( ipp, pf), 'wb' ).write(by)"
		]
	},
	"distraction_free":
	{
		"menu_visible": true,
		"show_minimap": false,
		"show_open_files": false,
		"show_tabs": false,
		"side_bar_visible": false,
		"status_bar_visible": false
	},
	"expanded_folders":
	[
		"/C/_pipeline/maya",
		"/C/_pipeline/maya/dev",
		"/C/_pipeline/maya/dev/rigging",
		"/C/_pipeline/maya/dev/rigging/behavior",
		"/C/_pipeline/maya/dev/rigging/builder",
		"/C/_pipeline/maya/dev/rigging/builder/ui",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets",
		"/C/_pipeline/maya/dev/rigging/task",
		"/C/_pipeline/maya/dev/rigging/task/config",
		"/C/_pipeline/maya/dev/rigging/utils",
		"/C/_pipeline/maya/doc",
		"/C/_pipeline/maya/tests",
		"/C/_pipeline/maya/utils",
		"/C/_pipeline/maya/utils/animation",
		"/C/_pipeline/maya/utils/common",
		"/C/_pipeline/maya/utils/common/config",
		"/C/_pipeline/maya/utils/modeling",
		"/C/_pipeline/maya/utils/rigging",
		"/C/_pipeline/maya/utils/rigging/config"
	],
	"file_history":
	[
		"/C/_pipeline/maya/dev/rigging/task/__init__.py",
		"/C/_pipeline/maya/dev/rigging/task/test/testTask.py",
		"/C/_pipeline/maya/dev/rigging/task/core/task.py",
		"/C/_pipeline/maya/dev/rigging/task/config/PROPERTY_ITEMS.py",
		"/C/_pipeline/maya/dev/rigging/task/base/newScene.py",
		"/C/_pipeline/maya/utils/common/uiUtils.py",
		"/C/_pipeline/maya/dev/rigging/task/base/dataImport.py",
		"/C/_pipeline/maya/dev/rigging/task/base/dataLoad.py",
		"/C/_pipeline/maya/dev/rigging/task/core/callback.py",
		"/C/_pipeline/maya/tests/chrTest.py",
		"/C/_pipeline/maya/dev/rigging/utils/kwargsUtils.py",
		"/C/_pipeline/maya/utils/common/modules.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/rigProgress.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/rigInfo.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/rigBuilder.py",
		"/C/_pipeline/maya/dev/rigging/utils/kwargs.py",
		"/C/_pipeline/maya/dev/rigging/utils/config/PROPERTY_ITEMS.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/buttonShelf.py",
		"/C/_pipeline/maya/utils/common/logUtils.py",
		"/C/_pipeline/maya/utils/common/variables.py",
		"/C/_pipeline/maya/tests/dataWidget.py",
		"/C/_pipeline/maya_oldCodes/lib/common/uiUtils.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/rigBuilder.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/rigBuild/rigBuildInfoTreeWidget.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/rigBuild/rigBuildWidget.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/dataInfo/dataInfoTreeWidget.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/dataInfo/dataInfoWidget.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/rigInfo/createRigDialog.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/rigInfo/rigInfoWidget.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/rigInfo/rigInfoLineEdit.py",
		"/C/_pipeline/maya_oldCodes/oldCode/riggingAPI/rigBuilderUI.py",
		"/C/_pipeline/maya_oldCodes/oldCode/UI/assetsManagerUI.py",
		"/C/_pipeline/maya_oldCodes/oldCode/UI/saveAssetUI.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/icons/__init__.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/propertyEditor.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/taskInfo.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/taskCreator.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/treeWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/core/builder.py",
		"/C/Program Files/Autodesk/Maya2018/devkit/devkit/other/pymel/extras/completion/py/maya/api/OpenMaya.py",
		"/C/_pipeline/maya/utils/common/files.py",
		"/C/_pipeline/maya/utils/common/config/PROPERTY_ITEMS.py",
		"/C/_pipeline/maya/dev/rigging/task/base/__init__.py",
		"/C/_pipeline/maya/dev/rigging/task/core/__init__.py",
		"/C/_pipeline/maya/dev/rigging/task/test/__init__.py",
		"/C/_pipeline/maya/tests/highlight.py",
		"/C/_pipeline/maya/tests/textEditor.py",
		"/C/Users/harri/Downloads/highlighter.py",
		"/C/_pipeline/maya/utils/common/config/__init__.py",
		"/C/_pipeline/maya/dev/rigging/__init__.py",
		"/C/_pipeline/maya/dev/rigging/task/core/dataLoad.py",
		"/C/_pipeline/maya/dev/rigging/task/core/dataImport.py",
		"/C/_pipeline/maya_oldCodes/assets/ui/assetManager.py",
		"/C/_pipeline/maya/tests/rigBuilder.py",
		"/C/_pipeline/maya_oldCodes/rigSys/ui/icon/__init__.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/config/PROPERTY_ITEMS.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/attrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/floatAttrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/boolAttrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/intAttrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/baseAttrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/dictAttrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/listAttrWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/stringAttrWidget.py",
		"/C/_pipeline/maya/tests/listViewAttr.py",
		"/C/_pipeline/maya/tests/testUI.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/listItemsWidget.py",
		"/C/_pipeline/maya/tests/dictInfo.py",
		"/C/_pipeline/maya/tests/licensepage.ini",
		"/C/_pipeline/maya/dev/rigging/builder/ui/widgets/stringWidget.py",
		"/C/_pipeline/maya/dev/rigging/builder/core/treeWidget.py",
		"/C/_pipeline/maya/utils/uiUtils/__init__.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/core/rigComponent.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/core/ikSolverComponent.py",
		"/C/_pipeline/maya/tests/data.py",
		"/C/_pipeline/maya/tests/treeList2.py",
		"/C/_pipeline/maya/tests/treeList4.py",
		"/C/_pipeline/maya/tests/treeList3.py",
		"/C/_pipeline/maya/tests/treeList.py",
		"/C/_pipeline/maya/tests/treeWidgetTest.py",
		"/C/_pipeline/maya/dev/rigging/builder/ui/__init__.py",
		"/C/_pipeline/maya/dev/rigging/builder/__init__.py",
		"/C/_pipeline/maya_oldCodes/lib/common/files/files.py",
		"/C/_pipeline/maya_oldCodes/rigSys/templates/builder.py",
		"/C/_pipeline/maya/dev/rigging/component/pack/pack.py",
		"/C/_works/maya/BromProject/assets/chrBrom/rig/components/buildScript/componentsInfo.py",
		"/C/_pipeline/maya/dev/rigging/component/core/base.py",
		"/C/_pipeline/maya/tests/callbackTest.py",
		"/C/_pipeline/maya/tests/methodTest.py",
		"/C/_pipeline/maya/dev/rigging/builder/core/base.py",
		"/C/_pipeline/maya_oldCodes/oldCode/riggingAPI/rigBuild/baseCore.py",
		"/C/_pipeline/maya/dev/rigging/component/core/__init__.py",
		"/C/_pipeline/maya/dev/rigging/builder/core/__init__.py",
		"/C/_pipeline/maya/dev/rigging/component/__init__.py",
		"/C/_pipeline/maya/dev/rigging/component/core/component.py",
		"/C/_pipeline/maya/NodeGraphQt/widgets/tab_search.py",
		"/C/_pipeline/maya/NodeGraphQt/widgets/properties_bin.py",
		"/C/_pipeline/maya/dev/rigging/ui/nodeGraph/widget/nodeScene.py",
		"/C/_pipeline/maya/dev/rigging/ui/nodeGraph/config/NODE.cfg",
		"/C/_pipeline/maya/dev/rigging/ui/nodeGraph/node/pipe.py",
		"/C/_pipeline/maya/dev/rigging/ui/nodeGraph/node/port.py",
		"/C/_pipeline/maya/dev/rigging/ui/nodeGraph/node/abstractNode.py",
		"/C/_pipeline/maya/dev/rigging/ui/nodeGraph/node/baseNode.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/qgraphics/port.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/constants.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/qgraphics/pipe.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/qgraphics/node_backdrop.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/qgraphics/node_abstract.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/__init__.py",
		"/C/_pipeline/maya/tests/NodeGraphQt/qgraphics/__init__.py",
		"/C/_pipeline/maya_oldCodes/lib/common/hierarchy.py",
		"/C/_pipeline/maya_oldCodes/lib/common/attributes.py",
		"/C/_pipeline/maya_oldCodes/lib/rigging/constraints.py",
		"/C/_pipeline/maya_oldCodes/lib/rigging/joints.py",
		"/C/_pipeline/maya_oldCodes/lib/common/transforms.py",
		"/C/_pipeline/maya_oldCodes/lib/modeling/curves.py",
		"/C/_pipeline/maya_oldCodes/lib/common/apiUtils.py",
		"/C/_pipeline/maya_oldCodes/lib/common/packages.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/core/componentsPackage.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/package/multiComponentsPackage.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/package/componentsBlendPackage.py",
		"/C/_pipeline/maya_oldCodes/rigSys/behaviors/ikSplineSolverBehavior.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/advance/ikRPsolverPlusComponent.py",
		"/C/_pipeline/maya_oldCodes/rigSys/components/base/fkChainComponent.py",
		"/C/_pipeline/maya_oldCodes/rigSys/behaviors/baseBehavior.py",
		"/C/_pipeline/maya_oldCodes/rigSys/behaviors/fkChainBehavior.py",
		"/C/_pipeline/maya_oldCodes/lib/rigging/controls/controls.py",
		"/C/_pipeline/maya_oldCodes/rigSys/behaviors/ikSCsolverBehavior.py"
	],
	"find":
	{
		"height": 43.0
	},
	"find_in_files":
	{
		"height": 172.0,
		"where_history":
		[
		]
	},
	"find_state":
	{
		"case_sensitive": false,
		"find_history":
		[
			"_collect_items",
			"refresh",
			"_task_create_window_open",
			"_get_unique_name",
			"_displayItems",
			"_create_item",
			"self._taskInfos",
			".close()",
			"_task_create_window",
			"right_clicked_menu",
			"QPushButtonSave",
			"button",
			"currentIndex",
			"button",
			"__setPathWinPop",
			"assetsManagerBaseLayout",
			"filterRegExpChanged",
			"assetsManagerBaseLayout",
			"Logger",
			"self.builder",
			"TaskItem",
			"png",
			"itemChanged",
			"TaskItem",
			"run_sel_tasks",
			"_run_task",
			"_setQTreeWidgetItemFontSize",
			"ICONS_STATUS",
			"icons",
			"collect_items",
			"ROLE_TASK_KWARGS",
			"ROLE_TASK_PRE",
			"_update_parent",
			"value",
			"self._update_parent",
			"parent",
			"json.dumps",
			"str(",
			"print type",
			"init_property",
			"TaskItem",
			"add_tree_items",
			"print",
			"PropertyDelegate",
			"ROLE_ITEM_KWARGS",
			"self._kwargs_ui",
			"_show_menu",
			"width",
			"self._size",
			"QSize",
			"PropertyItem",
			"tip",
			"ROLE_TASK_KWARGS",
			"_add_row_item",
			"PropertyItem",
			"self._size",
			"register_attributes",
			"value",
			"register_inputs",
			"register_attributes",
			"register_inputs",
			"register_attributes",
			"QStringList",
			"row",
			"PropertyItem",
			"register_single_kwarg",
			"variables",
			"role",
			"_Builder",
			"refresh_tasks",
			"itemRunner",
			"SC_REFRESH",
			"run_task",
			"SubMenu",
			"QSignalExecute",
			"ROLE_TASK_SECTION",
			"ItemRunner",
			"right_clicked_menu",
			"print",
			"QSignalProgressInit",
			"inspect",
			"ROLE_TASK_FUNC",
			"setData",
			"_add_child_item",
			"CheckState",
			"item.data",
			"_get_selection",
			"setText",
			"_rightClickedMenu",
			"print",
			"QSignalProgressStop",
			"run_task",
			"PropertyItem",
			"ROLE_VALUE",
			"itemFromIndex",
			"PROPERTY_ITEMS",
			"QSignalUpdateParent",
			"tree_hierarchy",
			"QSignalProgressInit",
			"self._run_all",
			"_run_all",
			"ItemRunner",
			"Signel",
			"Signal",
			"QSignelUpdateParent",
			"_set_data",
			"self._property",
			"qlabel",
			"click",
			"setCheckState",
			"icon",
			"QSignelUpdateParent",
			"Logger.warn",
			"PROPERTY_ITEMS",
			"variables",
			"register_kwargs",
			"register_attributes",
			"self._kwargs",
			"modules",
			"QSignalClose",
			"signal",
			"QStandardItem",
			"QtCore.",
			"QtGui.",
			"changeStyleTriggered",
			"signalNewPath",
			"Qt",
			"QSourceModel_version"
		],
		"highlight": true,
		"in_selection": false,
		"preserve_case": true,
		"regex": false,
		"replace_history":
		[
			"__resolution",
			"__description",
			"epsilon",
			"ikHandle",
			"clavicleFk",
			"pinkyTipFk",
			"pinkyMidFk",
			"pinkyBaseFk",
			"pinkyMetacarpalFk",
			"ringTipFk",
			"ringMidFk",
			"ringBaseFk",
			"ringMetacarpalFk",
			"middleTipFk",
			"middleMidFk",
			"middleBaseFk",
			"middleMetacarpalFk",
			"indexTipFk",
			"indexMidFk",
			"indexBaseFk",
			"indexMetacarpalFk",
			"thumbMidFk",
			"thumbTipFk",
			"thumbBaseFk",
			"clavicle",
			"sMultFkRot",
			"sDivideFkRot",
			"__sRes",
			"__sSide",
			"__sType",
			"createTransformNode",
			"__",
			"transformSnapAll",
			"transformSnapParent",
			"transformSnapScale",
			"transformSnapOrient",
			"transformSnapPoint",
			"decomposeName",
			"setPath",
			"setPushButtonEnabled",
			"listTypes",
			"listAssets",
			"listProjects",
			"__saveAsset",
			"__resetPath",
			"__setPathWinPop",
			"__getAssetFolders",
			"getAssetFolders",
			"listItemRightClicked",
			"setQMenuItemCreateEnabled",
			"openContainFolder",
			"QMenuItemDelete",
			"QMenuItemRename",
			"QMenuItemCreate",
			"listItemClick",
			"listItemRightClicked",
			"filterRegExpChanged",
			"__importAsset",
			"__openAsset",
			"__getCurrentAsset",
			"__setProject",
			"__setPushButtonEnabled",
			"__addQPushButton",
			"__setVersionComment",
			"__getCurrentVersion",
			"__setVersionEnabled",
			"__refreshVersion",
			"__addVersion",
			"__getVersionInfo",
			"__fileLayout",
			"__getCtrlShapeKnots",
			"__getCtrlShapeControlPoints",
			"__setMFnMesh",
			"__setSkinBlendWeights",
			"__setSkinWeights",
			"__getSkinBlendWeights",
			"__getSkinWeightsData",
			"__getSkinInfluenceArray",
			"__getComponentsFromMFnSkinCluster",
			"__getSkinWeightArray",
			"__setMFnSkinCluster",
			"filterRegExpChanged",
			"addFile",
			"refreshFileList",
			"setList",
			"__setList",
			"__syncCmd",
			"__refreshCmd",
			"__checkoutCmd",
			"__publishCmd",
			"__getSelectItem",
			"getVersionFiles",
			"getFoldersFromFolderList",
			"writeFolderListFile",
			"createFolderListFile",
			"getAssetFile",
			"getAssetDirectory",
			"fEndTime",
			"fStartTime",
			"_writeFolderListFile",
			"sFolderList",
			"self.dAssetData",
			"QTreeView_version",
			"QListWidget"
		],
		"reverse": false,
		"show_context": true,
		"use_buffer2": true,
		"whole_word": false,
		"wrap": true
	},
	"groups":
	[
		{
			"selected": 0,
			"sheets":
			[
				{
					"buffer": 0,
					"semi_transient": false,
					"settings":
					{
						"buffer_size": 37796,
						"regions":
						{
						},
						"selection":
						[
							[
								2364,
								2351
							]
						],
						"settings":
						{
							"auto_name": "@@ -1,19 +1,17 @@",
							"syntax": "Packages/Text/Plain text.tmLanguage",
							"translate_tabs_to_spaces": false
						},
						"translation.x": 0.0,
						"translation.y": 2702.0,
						"zoom_level": 1.0
					},
					"stack_index": 0,
					"type": "text"
				}
			]
		},
		{
			"sheets":
			[
			]
		}
	],
	"incremental_find":
	{
		"height": 43.0
	},
	"input":
	{
		"height": 60.0
	},
	"layout":
	{
		"cells":
		[
			[
				0,
				0,
				1,
				1
			],
			[
				1,
				0,
				2,
				1
			]
		],
		"cols":
		[
			0.0,
			0.863992718054,
			1.0
		],
		"rows":
		[
			0.0,
			1.0
		]
	},
	"menu_visible": true,
	"output.exec":
	{
		"height": 49.0
	},
	"output.find_results":
	{
		"height": 240.0
	},
	"pinned_build_system": "Packages/Python/Python.sublime-build",
	"project": "maya.sublime-project",
	"replace":
	{
		"height": 82.0
	},
	"save_all_on_build": true,
	"select_file":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_project":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"select_symbol":
	{
		"height": 0.0,
		"last_filter": "",
		"selected_items":
		[
		],
		"width": 0.0
	},
	"selected_group": 0,
	"settings":
	{
	},
	"show_minimap": true,
	"show_open_files": false,
	"show_tabs": true,
	"side_bar_visible": true,
	"side_bar_width": 316.0,
	"status_bar_visible": true,
	"template_settings":
	{
	}
}
